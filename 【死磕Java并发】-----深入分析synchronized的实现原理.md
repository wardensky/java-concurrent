# 【死磕Java并发】-----深入分析synchronized的实现原理


[来源](http://cmsblogs.com/?p=2071)

本文是对上述链接的学习，写的挺好的。


## 1. 基础知识点

## 2. Java对象头

HotSpot虚拟机的对象头包括两部分信息：Mark Word（标记字段）和 Klass Pointer（类型指针），其中Klass Point是是对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，Mark Word用于存储对象自身的运行时数据，它是实现轻量级锁和偏向锁的关键。

![](http://7xqucs.com1.z0.glb.clouddn.com/11111111111_2_thumb-1.jpg)

上面这个图说明了对象头的信息。


或者是下面这种。

HotSpot 虚拟机对象头 Mark Word

|存储内容|标志位|状态|
|-|-|-|
|对象哈希码、对象分代年龄|01|未锁定|
|指向锁记录的指针|00|轻量级锁定|
|指向重量级锁的指针|10|膨胀（重量级锁定）|
|空，不需要记录信息|11|GC标记|
|偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向|


## 3. monitor

## 4. 锁优化

锁主要存在四中状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

### a. 自旋锁

所谓自旋锁，就是让该线程等待一段时间，不会被立即挂起，看持有锁的线程是否会很快释放锁。怎么等待呢？执行一段无意义的循环即可（自旋）。

自旋等待不能替代阻塞，先不说对处理器数量的要求（多核，貌似现在没有单核的处理器了），虽然它可以避免线程切换带来的开销，但是它占用了处理器的时间。如果持有锁的线程很快就释放了锁，那么自旋的效率就非常好，反之，自旋的线程就会白白消耗掉处理的资源，它不会做任何有意义的工作，典型的占着茅坑不拉屎，这样反而会带来性能上的浪费。



### b. 适应性自旋锁

JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。



### c. 锁消除


锁消除就是JVM比较聪明，他发现有些部分其实没必要加锁，所以会把锁给去掉。

什么情况下是没必要加锁呢？一种是代码写的烂，随便加锁。另外就是下面这种情况。

vector本身是线程安全的，加了很多synchronized，但这是一个局部变量，没必要加锁，所以会出现锁消除。


```
public void vectorTest(){
       Vector<String> vector = new Vector<String>();
       for(int i = 0 ; i < 10 ; i++){
           vector.add(i + "");
       }

       System.out.println(vector);
   }
```

### d. 锁粗化

这个也好理解。我们自己写代码的时候，加锁的部分肯定是越少越好。但如果到了一个极端情况，很多加锁解锁操作在一起，反而会降低性能。JVM会很智能的把这些锁操作都放到一起。



### e. 偏向锁

### f. 轻量级锁
